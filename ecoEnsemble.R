library(devtools)
install_github("CefasRepRes/EcoEnsemble")
library("EcoEnsemble")
?EcoEnsemble

?define_priors
# encodes prior info on discrepancies for use in ensemble model
  
?EnsembleData
# used to convert input data into the required form
# to fit the ensemble model using Stan
# takes observations, simulators and priors as arguments

# examples of define_priors and EnsembleData:

#N_species <- 4
#priors <- define_priors(ind_st_var_params = list(25, 0.25),
#                        ind_st_cor_form = "lkj", #Using an LKJ distribution for individual short-term discrepancies
#                        ind_st_cor_params = 30, #The parameter is 30
#                        ind_lt_var_params = list(rep(25,N_species),rep(0.25,N_species)),
#                        ind_lt_cor_form = "beta",
#                        ind_lt_cor_params = list(matrix(40,N_species, N_species), matrix(40, N_species, N_species)),
#                        sha_st_var_exp = 3,
#                        sha_st_cor_form = "lkj",
#                        sha_st_cor_params = 30,
#                        sha_lt_sd = rep(4,N_species))
#ensemble_data <- EnsembleData(observations = list(SSB_obs, Sigma_obs),
#                              simulators = list(list(SSB_ewe, Sigma_ewe, "EwE"),
#                                                list(SSB_fs,  Sigma_fs, "FishSUMS"),
#                                                list(SSB_lm,  Sigma_lm, "LeMans"),
#                                                list(SSB_miz, Sigma_miz, "mizer")),
#                              priors = priors)


?EnsembleFit
# container for the samples or point estimates generated by the fitted
# Stan models

# just plug in ensemble_data here
# ensemble_fit <- EnsembleFit(ensemble_data)

?EnsembleSample
# container for the samples or and MLE point estimates generated
# by the Kalman filter

# just plug in ensemble_fit here
# ensemble_sample <- EnsembleSample(ensemble_fit)

?fit_ensemble_model
# runs the MCMC of the ensemble model through Stan.
# (depending on size of datasets can take a long time)
# use after define_priors?

#fit <- fit_ensemble_model(observations = list(SSB_obs, Sigma_obs),
#simulators = list(list(SSB_ewe, Sigma_ewe, "EwE"),
#                  list(SSB_fs,  Sigma_fs, "FishSUMS"),
#                  list(SSB_lm,  Sigma_lm, "LeMans"),
#                  list(SSB_miz, Sigma_miz, "Mizer")),
#priors = priors,
#full_sample = FALSE) #Only optimise in this case
#Run a full sample
#fit1 <- fit_ensemble_model(observations = list(SSB_obs, Sigma_obs),
#                           simulators = list(list(SSB_ewe, Sigma_ewe, "EwE"),
#                                             list(SSB_fs,  Sigma_fs, "FishSUMS"),
#                                             list(SSB_lm,  Sigma_lm, "LeMans"),
#                                             list(SSB_miz, Sigma_miz, "Mizer")),
#                           priors = priors,
#                           control=list(adapt_delta = 0.99)) # Additional Stan parameters.

?generate_sample
# Methods to generates samples of the latent variables in the
# ensemble model by sampling from the Kalman filter.

# After fit_ensemble_model, generate_sample example
# sample <- generate_sample(fit_sample, num_samples = 2000)


?get_mcmc_ensemble_model
# Gets the unfit, compiled Stan object encoding the ensemble model.
# This allows for manual fitting of the ensemble model directly using.
# Assuming this won't be required. On second look, now unsure!

#mod <- get_mcmc_ensemble_model()
#ensemble_data <- EnsembleData(observations = list(SSB_obs, Sigma_obs),
#                              simulators = list(list(SSB_ewe, Sigma_ewe, "EwE"),
#                                                list(SSB_fs,  Sigma_fs, "FishSUMS"),
#                                                list(SSB_lm,  Sigma_lm, "LeMans"),
#                                                list(SSB_miz, Sigma_miz, "mizer")),
#                              priors = priors)
#out <- rstan::sampling(mod, ensemble_data@stan_input, chains=(parallel::detectCores()-1))

?Sigma_ewe
# A 4x4 covariance matrix quantifying the parameter uncertainty
# of Ecopath with EcoSim

# These Sigma matrices exist for each simulator.

?SSB_ewe

# here is a dataset containing the spawning stock biomass of
# Norway Pout, herring, cod and sole in the North Sea
# between 1991-2050 under an MSY fishing scenario from
# EcoPath with EcoSim.

# I assume we would replace SSB_ewe with the data that we have
# from the 40 iterations and 3 fishing scenarios. 
# I also assume we would include the SSB of all functional groups?
# But I'm not too sure.

SSB_ewe
# Clearly no sandeels here, which is essential

?SSB_obs
?Sigma_obs

# These are stock assessments --- I assume used to train the models 
# in some way?

# I assume the plan is to run each of these simulators (mizer, FishSUMS, LeMans,
# and we have already got the output for EwE) under each of the 3 fishing 
# scenarios, meaning I need all possible inputs for all functional groups
# that are included in each of these models, then we take the outputs
# from the simulators and use these as the SSB to put in the ensemble model.

# Assume EnsembleData would be first used to get the data into the right
# format.

# Running the example provided:

N_species <- 4
priors <- define_priors(ind_st_var_params = list(25, 0.25),
                        ind_st_cor_form = "lkj", #Using an LKJ distribution for individual short-term discrepancies
                        ind_st_cor_params = 30, #The parameter is 30
                        ind_lt_var_params = list(rep(25,N_species),rep(0.25,N_species)),
                        ind_lt_cor_form = "beta",
                        ind_lt_cor_params = list(matrix(40,N_species, N_species), matrix(40, N_species, N_species)),
                        sha_st_var_exp = 3,
                        sha_st_cor_form = "lkj",
                        sha_st_cor_params = 30,
                        sha_lt_sd = rep(4,N_species))
ensemble_data <- EnsembleData(observations = list(SSB_obs, Sigma_obs),
                              simulators = list(list(SSB_ewe, Sigma_ewe, "EwE"),
                                                list(SSB_fs,  Sigma_fs, "FishSUMS"),
                                                list(SSB_lm,  Sigma_lm, "LeMans"),
                                                list(SSB_miz, Sigma_miz, "mizer")),
                              priors = priors)
ensemble_fit <- EnsembleFit(ensemble_data)
ensemble_sample <- EnsembleSample(ensemble_fit)
fit <- fit_ensemble_model(observations = list(SSB_obs, Sigma_obs),
                          simulators = list(list(SSB_ewe, Sigma_ewe, "EwE"),
                                            list(SSB_fs,  Sigma_fs, "FishSUMS"),
                                            list(SSB_lm,  Sigma_lm, "LeMans"),
                                            list(SSB_miz, Sigma_miz, "Mizer")),
                          priors = priors,
                          full_sample = FALSE)
str(fit)

fit1 <- fit_ensemble_model(observations = list(SSB_obs, Sigma_obs),
                           simulators = list(list(SSB_ewe, Sigma_ewe, "EwE"),
                           list(SSB_fs,  Sigma_fs, "FishSUMS"),
                           list(SSB_lm,  Sigma_lm, "LeMans"),
                           list(SSB_miz, Sigma_miz, "Mizer")),
                           priors = priors,
                           control=list(adapt_delta = 0.99))

sample <- generate_sample(fit, num_samples = 2000)
sample@mle

# generate_sample function

a <- function (fit, num_samples = 2000) 
{
  stan_input <- fit@ensemble_data@stan_input
  full_sample <- !is.null(fit@samples)
  transformed_data <- EcoEnsemble:::get_transformed_data(fit)
  rstan::expose_stan_functions(EcoEnsemble:::stanmodels$KF_back)
  if (full_sample) {
    ex.fit <- rstan::extract(fit@samples)
    num_samples <- nrow(ex.fit$x_hat)
    mle <- sapply(1:num_samples, get_mle, ex.fit = ex.fit, 
                  transformed_data = transformed_data, time = stan_input$time, 
                  simplify = F)
  }
  else {
    ex.fit <- fit@point_estimate$par
    mle <- EcoEnsemble:::get_mle(x = 1, ex.fit, transformed_data = transformed_data, 
                   time = stan_input$time)
  }
  sammy <- sapply(1:2000, EcoEnsemble:::gen_sample, ex.fit = ex.fit, 
                  transformed_data = transformed_data, time = stan_input$time, 
                  simplify = F)
  if (full_sample) {
    tmp <- mapply(function(x, y) {
      y - x$sam_x_hat + x$sam_x
    }, y = mle, x = sammy)
    sample_ret <- array(as.numeric(unlist(tmp)), dim = c(nrow(mle[[1]]), 
                                                         ncol(mle[[1]]), num_samples))
    mle <- array(as.numeric(unlist(mle)), dim = c(nrow(mle[[1]]), 
                                                  ncol(mle[[1]]), num_samples))
  }
  else {
    tmp <- lapply(sammy, function(x, y) {
      y - x$sam_x_hat + x$sam_x
    }, y = mle)
    sample_ret <- array(as.numeric(unlist(tmp)), dim = c(nrow(mle), 
                                                         ncol(mle), num_samples))
  }
  return(EnsembleSample(fit, mle, sample_ret))
}
a(fit = fit, num_samples = 2000)
KalmanFilter_back(params$AR_params, params$lt_discrepancies, 
transformed_data$all_eigenvalues_cov, params$SIGMA, transformed_data$bigM, 
params$SIGMA_init, params$x_hat, stan_input$time, transformed_data$new_data, 
transformed_data$observation_available)

# From EcoEnsemble:::get_mle:
params <- EcoEnsemble:::get_parameters(ex.fit, x)

params$AR_params # vector of length 24
params$lt_discrepancies # vector of length 24
transformed_data$all_eigenvalues_cov # vector of length 19 = N + sum(model_num_species)
params$SIGMA # 24 x 24 matrix
# Looks like params$SIGMA is just a large matrix of block matrices
# correponding to 'updated' (unsure) covariance matrices for all
# 5 sigma being considered --- uncertainty on stock assessments
# for each fish species (N_species=4), then for each of the 4
# simulators --- but this would make a 20 x 20, so missing something here

transformed_data$bigM # 19 x 24 matrix. 
# nrow = N + sum(model_num_species) = 4 + sum(4, 3, 4, 4) = 19
# ncol = (M + 2) * N = (4 + 2) * 4 = 24. M is number simulators, N is total number species
params$SIGMA_init # 24 x 24 matrix
params$x_hat # vector of length 24
transformed_data$new_data # 67 x 19 matrix (67 is number of years considered)
transformed_data$observation_available # 67 x 19 matrix, filled with 1s or 0s

# Looking at EcoEnsemble:::get_transformed_data function

b <- function (fit) 
{
  stan_input <- fit@ensemble_data@stan_input
  N <- stan_input$N
  M <- stan_input$M
  model_num_species <- stan_input$model_num_species
  obs_covariances <- stan_input$obs_covariances
  Ms <- stan_input$Ms
  model_covariances <- stan_input$model_covariances
  observation_times <- stan_input$observation_times
  time <- stan_input$time
  observations <- stan_input$observations
  model_outputs <- stan_input$model_outputs
  bigM <- matrix(0, N + sum(model_num_species), (M + 2) * N)
  all_eigenvalues_cov <- rep(0, N + sum(model_num_species))
  all_eigenvectors_cov = matrix(0, N + sum(model_num_species), 
                                N + sum(model_num_species))
  new_data <- observation_available <- matrix(0, time, N + 
                                                sum(model_num_species))
  bigM[1:N, 1:N] = diag(N)
  tmp_eigen <- eigen(obs_covariances, symmetric = T)
  all_eigenvalues_cov[1:N] <- tmp_eigen$values
  all_eigenvectors_cov[1:N, 1:N] <- tmp_eigen$vectors
  if (M > 0) {
    bigM[(N + 1):(N + model_num_species[1]), 1:N] <- Ms[1:model_num_species[1], 
    ]
    bigM[(N + 1):(N + model_num_species[1]), (N + 1):(2 * 
                                                        N)] <- Ms[1:model_num_species[1], ]
    bigM[(N + 1):(N + model_num_species[1]), (2 * N + 1):(3 * 
                                                            N)] <- Ms[1:model_num_species[1], ]
    tmp_eigen <- eigen(matrix(model_covariances[1:(model_num_species[1]^2)], 
                              model_num_species[1], model_num_species[1]), symmetric = T)
    all_eigenvalues_cov[(N + 1):(N + model_num_species[1])] <- tmp_eigen$values
    all_eigenvectors_cov[(N + 1):(N + model_num_species[1]), 
                         (N + 1):(N + model_num_species[1])] = tmp_eigen$vectors
    if (M > 1) {
      for (i in 2:M) {
        start_index <- N + sum(model_num_species[1:(i - 
                                                      1)]) + 1
        end_index <- N + sum(model_num_species[1:i])
        Ms_transformation <- Ms[(sum(model_num_species[1:(i - 
                                                            1)]) + 1):sum(model_num_species[1:i]), ]
        bigM[start_index:end_index, 1:N] <- Ms_transformation
        bigM[start_index:end_index, (N + 1):(2 * N)] <- Ms_transformation
        bigM[start_index:end_index, ((i + 1) * N + 1):((i + 
                                                          2) * N)] <- Ms_transformation
        tmp_eigen <- eigen(matrix(model_covariances[(cumsum(model_num_species^2)[i - 
                                                                                   1] + 1):(cumsum(model_num_species^2)[i])], 
                                  model_num_species[i], model_num_species[i]), 
                           symmetric = T)
        all_eigenvalues_cov[start_index:end_index] <- tmp_eigen$values
        all_eigenvectors_cov[start_index:end_index, start_index:end_index] <- tmp_eigen$vectors
      }
    }
  }
  for (i in 1:time) {
    observation_available[i, 1:N] = rep(observation_times[i, 
                                                          1], N)
    if (M > 0) {
      observation_available[i, (N + 1):(N + model_num_species[1])] <- rep(observation_times[i, 
                                                                                            2], model_num_species[1])
      if (M > 1) {
        for (j in 2:M) {
          observation_available[i, (N + sum(model_num_species[1:(j - 
                                                                   1)]) + 1):(N + sum(model_num_species[1:j]))] <- rep(observation_times[i, 
                                                                                                                                         j + 1], model_num_species[j])
        }
      }
    }
    new_data[i, ] <- t(all_eigenvectors_cov) %*% matrix(c(observations[i, 
    ], model_outputs[i, ]), ncol = 1)
  }
  bigM <- t(all_eigenvectors_cov) %*% bigM
  return(list(bigM = bigM, all_eigenvalues_cov = all_eigenvalues_cov, 
              new_data = new_data, observation_available = observation_available))
}

# EcoEnsemble:::plot.EnsembleSample function

function (sample, variable = 1, quantiles = c(0.05, 0.95)) 
{
  fit <- sample@ensemble_fit
  ensemble_data <- fit@ensemble_data
  observations <- ensemble_data@observations[[1]]
  simulators <- ensemble_data@simulators
  stan_input <- ensemble_data@stan_input
  if (is.double(variable)) {
    variable <- colnames(observations)[variable]
  }
  if (is.na(variable) || !(variable %in% colnames(observations))) {
    stop(paste0("Invalid variable. This should be the name of a species or an index less than ", 
                ncol(observations)))
  }
  df <- fit@ensemble_data@stan_input$observations[, which(colnames(observations) == 
                                                            variable)]
  if (!is.null(fit@samples)) {
    df <- cbind(df, apply(sample@mle[, which(colnames(observations) == 
                                               variable), ], 1, median))
    df <- cbind(df, apply(sample@sample[, which(colnames(observations) == 
                                                  variable), ], 1, quantile, min(quantiles)))
    df <- cbind(df, apply(sample@sample[, which(colnames(observations) == 
                                                  variable), ], 1, quantile, max(quantiles)))
    colnames(df)[(ncol(df) - 2):ncol(df)] <- c("Ensemble true value", 
                                               "EnsembleLower", "EnsembleUpper")
  }
  else {
    df <- cbind(df, sample@mle[, which(colnames(observations) == 
                                         variable)])
    colnames(df)[ncol(df)] <- "Ensemble true value"
  }
  for (i in 1:length(simulators)) {
    simulator <- simulators[[i]]
    if (!(variable %in% colnames(simulator[[1]]))) {
      next
    }
    relative_index <- which(colnames(simulator[[1]]) == variable)
    index <- cumsum(stan_input$model_num_species)[i] - stan_input$model_num_species[1] + 
      relative_index
    df <- cbind(df, stan_input$model_outputs[, index])
    colnames(df)[ncol(df)] <- paste0("Simulator ", 
                                     i)
    if (length(simulator) == 3) {
      colnames(df)[ncol(df)] <- simulator[[3]]
    }
  }
  colnames(df)[1] <- "Observations"
  start_year <- min(as.double(rownames(observations)))
  df <- cbind(start_year:(start_year + stan_input$time - 1), 
              df)
  colnames(df)[1] <- "Year"
  df <- data.frame(df)
  for (i in 1:ncol(df)) {
    df[df[, i] == 0, i] = NA
  }
  if (!is.null(fit@samples)) {
    df <- reshape2::melt(df, id.vars = c("Year", "EnsembleLower", 
                                         "EnsembleUpper"), variable.name = "Simulator")
    return(plot_values_sample_gg(df, variable))
  }
  df <- reshape2::melt(df, id.vars = c("Year"), variable.name = "Simulator")
  return(plot_values_optimised_gg(df, variable))
}

plot(x = 1984:2050, y = sample@mle[,1], type = "l")
sample@mle[,5]
sample@mle[,9]
sample@mle[,13]
sample@mle[,17]
unique(sample@mle[1,])
# almost certain that the first N_species columns of generate_sample
# object are the mle ensemble true values for the N_species